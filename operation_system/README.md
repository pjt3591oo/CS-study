<details>
<summary>Table of Contents</summary>

- [프로세스와 스레드](#프로세스와-스레드)
- [동기와 비동기](#동기와-비동기)
- [블락킹과 논블락킹](#블락킹과-논블락킹)
</details>

## 프로세스와-스레드
### 참고 자료
[자료 1](https://velog.io/@aeong98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C) [자료 2](https://zangzangs.tistory.com/108) [자료 3](https://m.blog.naver.com/merongvvvv/222038241661) [자료 4](https://m.blog.naver.com/merongvvvv/222039850144) [자료 5](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

### 프로세스(Process)
#### 프로세스가 도대체 뭐야?
> * 실행 중에 있는 프로그램   
> * 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라 불린다.   

#### 프로세스의 문맥(context)
> 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보   
 
**왜 필요한건데?**   
현대의 운영체제는 여러 프로세스가 함께 수행되는 시분할 시스템 환경이다. 시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간동안 CPU를 점유하고 다른 프로세스에게 넘겨주고 다시 차례가 되면 CPU를 점유하여 명령을 수행합니다. 다시 명령을 수행하기 위해서 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 상태를 재현할 수 있는 정보가 필요했습니다. 그 필요한 정보가 바로 프로세스 문맥(process context)입니다.   

    ex) 카카오톡을 켜놓고 유튜브로 노래를 들으면서 웹서핑을 하는 것은 사용자 입장에서 동시에 일어나는 일처럼 보이지만 실제로는 그렇지 않음.   

![플래시](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2ewSMyMQMz9DtaG4gw6kIbfo9Cejte_QCuA&usqp=CAU)   
(CPU는 마치 ... 플래시 같은 느낌 ...)


**문맥 종류**   
1.  CPU 수행상태를 나타내는 하드웨어 문맥 : 현시점에서 이 프로세스가 'instruction(기계어)을 어디까지 수행했는가?'를 알기 위한 요소. (PC, 각종 register:주로 register가 현재 어떤 값을 갖고 있었는가 를 나타냄)   
2. 프로세스 주소공간 : 현 시점의 'code, data, stack에 어떤 내용이 들어 있는가?' 를 알아야 이 프로세스의 현재 상태를 정확히 알 수 있다.   
3. 프로세스 관련 커널 자료구조 : 프로세스 하나 생길 때마다 OS는 그 프로세스를 관리하기 위해 자신의 data 구조에 자료구조(PCB)를 두고있다. 즉, PCB에 얼마나 CPU와 메모리를 줘야 할지, 나쁜 짓을 하고있진 않은지 관리하는 역할. (OS는 지금 돌아가는 프로그램을 관리하는 역할)   

#### 프로세스의 상태(State)
* 프로세스는 상태(state)가 변경되며 수행된다.
    * Running
        * CPU 를 잡고 instruction 을 수행중인 상태
    * Ready
        * CPU 를 기다리는 상태
    * Blocked (waiting, sleep)
        * CPU를 주어도 당장 instruction 을 수행할 수 없는 상태
        * Process 자신이 요청한 event(예: I/O) 가 즉시 만족되지 않아, 이를 기다리는 상태
        * (예) 디스크에서 file 을 읽어와야 하는 경우
    * New : 디스크에서 메모리로 프로그램이 올라가 실행준비를 하는 상태
    * Terminated : 수행 (execution)이 끝난 상태

#### 문맥 교환 (Context Switch)
> 한 프로세스에서 다른 프로세스로 CPU의 제어권을 넘겨주는 과정(단, OS로 넘어가는 것은 문맥 교환이 아니다. - 하나의 프로세스가 사용자 모드에서 실행되다가, 커널 모드로 실행 모드만 바뀌는 것일 뿐 CPU 를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문)   

![](https://mblogthumb-phinf.pstatic.net/MjAyMDA3MjJfMTA2/MDAxNTk1MzkxNTI3NjU5.HIrzeAJLacDUQDPnP_vhoNuYTzqO8ubuVMKxg5Ee1_Qg.sYkTesnJoAkCMgJcCeQrWdm5BWpYbqgTtFZWAJGiaTYg.PNG.merongvvvv/image.png?type=w800)   

현재 프로세스 A 가 CPU 를 사용하고 있는 상황에서 CPU 사용시간이 끝나, 다음 프로세스에게 CPU 를 넘겨주어야 합니다. 스케줄링 알고리즘에 의해 다음 CPU 를 받을 프로세스B 가 선택되었고, 타이머 인터럽트가 발생해 CPU 제어권이 운영체제 커널에 넘어가게 됩니다.   

이 과정에서 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행중이던 프로세스 A 의 문맥을 자신의 PCB 에 저장하고, 프로세스 B 는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원 시키는 과정을 거치게 된다.   

CPU가 동시에 여러개의 프로세스를 실행시키는 것처럼 보이지만, 사실은 CPU가 재빠르게 여러 프로세스를 번갈아가며 실행하고 관리하고 있는것. 이때 프로세스를 번갈아가면서 처리하는 것을 Context Switching(문맥교환)이라고 한다.   

### 스레드
> 프로세스 내에서 실행되는 여러 흐름의 단위. 프로세스의 처리속도를 높이기 위해 프로세스가 수행해야 할 여러 작업들을 나누어 수행 할 수 있도록 설계한 것   

### 프로세스 VS 스레드
운영체제는 프로세스마다 각각 독립된 메모리 영역을, Code/Data/Stack/Heap의 형식으로 할당해 준다. 각각 독립된 메모리 영역을 할당해 주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.

![](https://velog.velcdn.com/images%2Fraejoonee%2Fpost%2Fb7939911-f3e8-48ac-abb8-63d8a17d0444%2F103.png)   

이와 다르게 스레드는 메모리를 서로 공유할 수 있다고 언급했었다. 이에 대해 더 자세히 설명하자면, 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 공유한다. 따라서 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있게 된다.   

![](https://velog.velcdn.com/images%2Fraejoonee%2Fpost%2Fb91490ed-c67b-407d-8fea-a8d6fdb22559%2F104.png)   

여기서 프로세스와 스레드의 중요한 차이를 하나 더 알 수 있게 된다. 만약 한 프로세스를 실행하다가 오류가 발생해서 프로세스가 강제로 종료된다면, 다른 프로세스에게 어떤 영향이 있을까? 공유하고 있는 파일을 손상시키는 경우가 아니라면 아무런 영향을 주지 않는다.

그런데 스레드의 경우는 다르다. 스레드는 Code/Data/Heap 메모리 영역의 내용을 공유하기 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다.   

#### 프로세스가 다른 프로세스의 정보에 접근하는 방법   
프로세스 간 정보를 공유하는 방법에는 다음과 같은 방법들이 있다. 다만 이 경우에는 단순히 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 앞서 말했듯 자원 부담이 크다.

1. IPC(Inter-Process Communication)을 사용한다.
2. LPC(Local inter-Process Communication)을 사용한다.
3. 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정해주면 된다.   

#### 멀티 스레드
> 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것   

> **멀티스레드의 장점**
> 
> 1. Context-Switching할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있다.
> 2. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적어서 응답 시간이 빠르다.   
>
> **멀티스레드의 단점**
>
> 1. 스레드 하나가 프로세스 내 자원을 망쳐버린다면 모든 프로세스가 종료될 수 있다.
> 2. 자원을 공유하기 때문에 필연적으로 ***동기화 문제***가 발생할 수밖에 없다.

#### 동기와 비동기

#### 블락킹과 논블락킹
